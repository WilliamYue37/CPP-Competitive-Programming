<snippet>
	<content><![CDATA[
struct SegmentTree {
	int N;
	vector<int> minimum, delta;

	SegmentTree() {}

	SegmentTree(int N) {
		this->N = N;
		minimum.resize(4 * N + 1);
		delta.resize(4 * N + 1);
		//you don't need to init unless default values are not zero
		//init(1, 0, N - 1);
	}
	
	void update(int l, int r, int val) {update(1, 0, N - 1, l, r, val);} //inclusive range
	
	int query(int l, int r) {return query(1, 0, N - 1, l, r);} //inclusive range
	
	void init(int i, int lo, int hi) {
		//if default segtree values are not zero, initialize node i
		if (lo == hi) return;
		
		int m = (lo + hi) / 2;
		init(2 * i, lo, m);
		init(2 * i + 1, m + 1, hi);
	}
	
	void push(int i) {
		delta[2 * i] += delta[i];
		delta[2 * i + 1] += delta[i];
		delta[i] = 0;
	}

	void pull(int i) {
		minimum[i] = min(minimum[2 * i] + delta[2 * i], minimum[2 * i + 1] + delta[2 * i + 1]);
	}
	
	void update(int i, int lo, int hi, int l, int r, int val) {
		if (r < lo || hi < l) return;
		if (l <= lo && hi <= r) {
			delta[i] += val;
			return;
		}
		
		push(i);
		
		int m = (lo + hi) / 2;
		update(2 * i, lo, m, l, r, val);
		update(2 * i + 1, m + 1, hi, l, r, val);
		
		pull(i);
	}
	
	int query(int i, int lo, int hi, int l, int r) {
		if (r < lo || hi < l) return (1 << 29);
		if (l <= lo && hi <= r) {
			return minimum[i] + delta[i];
		}
		
		push(i);
		
		int m = (lo + hi) / 2;
		int minLeft = query(2 * i, lo, m, l, r);
		int minRight = query(2 * i + 1, m + 1, hi, l, r);
		
		pull(i);
		
		return min(minLeft, minRight);
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>segmentTree</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
	<description>Segment Tree</description>
</snippet>